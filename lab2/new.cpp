#include <bits/stdc++.h>
#include "combo.h"
using namespace std;
#define pii pair<int, int>

pii nil = {-1, -1};



struct Node{
    int path_cost; // accumulated cost
    int color; // visited = 1, else 0 
    int score; // score generated by heuristic
    bool visited; 
    pii parent;

    bool operator <(const Node &n) const{
        return path_cost < n.path_cost; 
    }

    Node(){
        path_cost = 0;
        color = 0;
        score = 0;
        visited = false;
        parent = nil;
    }
};


class JobAllocation{
    vector<vector<int>> cost;
    vector<vector<Node>> G;
    int N;

    set<string> open, closed; 

    
    // cost:   Jobs ->
    // Person
    // |
    // âŒ„

    vector<int> start(){
        // Start = {0, 1, 2, 3, ..., N-1}
        vector<int> v;
        for(int i=0; i<N; ++i)
            v.push_back(i);
        return v;
    }


    Node& getNode(pii pos){
        return G[pos.first][pos.second];
    }


    int getCost(pii pos){
        if(pos == nil)
            return 0;
        return cost[pos.first][pos.second];
    }

    
    int getScore(pii pos){
        if(pos == nil)
            return -1;
        return getNode(pos).score;
    }


    int getPathCost(pii pos){
        if(pos == nil)
            return 0;
        return getNode(pos).path_cost;
    }


    vector<pii> getPath(pii pos){
        vector<pii> path;
        for(pii node=pos; node!=nil; node=getNode(node).parent){
            path.push_back(node);
        }
        return path;
    }


    bool goalTest(vector<int> state, int constraint=INT_MAX){
        /* 
         *  Checks if every job is assigned to a unique person
         *   
         * @params:
         *          state(vector<pii>): vector of assignments in form of (personIndex, jobIndex)
         *          constraint(int): maximum bound constraint for path cost
         * @return:
         *          Boolean of whether state is equal to goal or not.
         */
        if(state.empty())
            return false;
        
        set<int> uniqueJob;
        for(int job: state){
            uniqueJob.insert(job);
        }

        return (
            (uniqueJob.size() == N) && 
            (h(state) <= constraint)
        );
    }
    

    vector<vector<int>> movegen(vector<int> node, int density=2){
        int cost = h(node);
        vector<vector<int>> neighbours;

        vector<vector<int>> combos = nCr(node.size(), density);
        for(vector<int> combo: combos){
            vector<int> neighbour = node;
            int d = density-1;
            while(d--){
                for(int i=1; i<combo.size(); ++i){
                    swap(combo[i], combo[i-1]);
                    swap(neighbour[combo[i]], neighbour[combo[i-1]]);
                }
                // cout << "Neighbour: ";
                // for(int i: neighbour)
                //     cout << i << " ";
                // cout << "\n";

                neighbours.push_back(neighbour);

                // cout << "Combo: ";
                // for(int i: combo)
                //     cout << i << " ";
                // cout << "\n";
            }
        }            
        return neighbours;
    }


    int lookAhead(vector<pii> nextMoves, pii pos){
        int i = nextMoves.front().first + 1;
        int sum = 0;

        // printf("nextMoves: \n");
        vector<int> jobsFree;
        for(pii pair: nextMoves){
            // printf("{%d, %d} \n", pair.first, pair.second);
            if(pair != pos)
                jobsFree.push_back(pair.second);
        }
        
        for(; i<N; ++i){
            for(int j: jobsFree){
                sum += cost[i][j];
                // printf("Add %d, %d\n", i, j);
            }
        }
        // printf("Cost: %d, LookAhead: %d\n\n", getCost(pos), sum);
        return sum;
    }


    int h(vector<int> node){
        int sum = 0;
        for(int i=0; i<node.size(); ++i)
            sum += getCost({i, node[i]});        
        return sum;
    }
    

    vector<int> headSortMovegen(vector<int> node, int density){
        int cost = h(node);
        vector<vector<int>> neighbours = movegen(node, density);
        sort(neighbours.begin(), neighbours.end(), [this](const vector<int>& l, const vector<int>& r){
            return h(l) < h(r);
        });

        // Return head with minimum heuristic value
        return neighbours[0];
    }


    string toString(vector<int> node){
        string state = "";
        for(int i: node)
            state += to_string(i) + ",";
        return state;
    }


    vector<int> bestFirstSearch(int constraint=INT_MAX){
        
        // Init
        vector<int> source = start();

        priority_queue<vector<int>, vector<vector<int>>, function<bool(vector<int>, vector<int>)>> Q( [this](vector<int> l, vector<int> r) -> bool {// Lambda Comparator Constructor for function<>
                // Min Priority Queue based on score
                return (h(l) > h(r));
        });
        

        // Push Source,
        Q.push(source);
        while(!Q.empty()){

            // Get top of queue
            vector<int> node = Q.top();
            Q.pop();

            printf("\nPOP: ");
            printPath(node);

            // Test Goal
            if(goalTest(node, constraint)){
                cout << "Goal Found\n";
                return node;
            }

            // Explore successor moves
            for(vector<int> move: movegen(node)){
                if(closed.find(toString(move)) == closed.end()){
                    closed.insert(toString(move));
                    Q.push(move);
                }
            }
        }
        return source;   
    }


    vector<int> hillClimbing(vector<int> node, int density=2){
        
        vector<int> newNode = headSortMovegen(node, density);

        while(h(newNode) < h(node)){
            node = newNode;
            newNode = headSortMovegen(node, density);
            printPath(node);
        }
        return node;
    }


    vector<vector<int>> beam(vector<vector<int>> nodes, int beam_width=2){
        
        if(nodes.empty())
            return nodes;

        // Sort based on heuristic -> h()    
        sort(nodes.begin(), nodes.end(), [this](const vector<int>& l, const vector<int>& r){
            return h(l) < h(r);
        });

        // Make beam, atmost beamWidth elements
        vector<vector<int>> filtered_nodes;
        filtered_nodes.push_back(nodes[0]);

        for(int bw=1; (bw < beam_width) && (bw < nodes.size()); bw++){
            // Only push if heuristic value equal to minimum 
            if(h(nodes[bw]) == h(nodes[0])){
                filtered_nodes.push_back(nodes[bw]);
            }
        }
        return filtered_nodes;
    }


    vector<int> beamSearch(int constraint=INT_MAX, int beam_width = 2){
        
        // Init
        vector<int> source = start();

        priority_queue<vector<int>, vector<vector<int>>, function<bool(vector<int>, vector<int>)>> Q( [this](vector<int> l, vector<int> r) -> bool {// Lambda Comparator Constructor for function<>
                // Min Priority Queue based on score
                return (h(l) > h(r));
        });
        

        // Push Source,
        Q.push(source);
        while(!Q.empty()){

            // Get top of queue
            vector<int> node = Q.top();
            Q.pop();

            printf("\nPOP: ");
            printPath(node);

            // Test Goal
            if(goalTest(node, constraint)){
                cout << "Goal Found\n";
                return node;
            }

            // Explore successor moves
            for(vector<int> move: beam(movegen(node), beam_width)){
                if(closed.find(toString(move)) == closed.end()){
                    closed.insert(toString(move));
                    Q.push(move);
                }
            }
        }
        return source;   
    }



    vector<int> vnd(){
        
        vector<int> node = start();
        int density = 2;
        while(density < N){
            cout << "Density: " << density << "\n";
            node = hillClimbing(node, density);
            density ++;
        }
        return node;
    }

public:
    void input(){
        int cell_cost;
        
        // Input dimension N
        cin >> N;
        
        // Input N x N cost matrix
        for(int i=0; i<N; ++i){
            vector<int> rowC;
            vector<Node> rowG;
            
            for(int j=0; j<N; ++j){
                cin >> cell_cost;
                rowC.push_back(cell_cost);
                rowG.push_back(Node());
            }
            JobAllocation::cost.push_back(rowC);
            JobAllocation::G.push_back(rowG);
        }
    }


    void printPath(vector<int> state, bool verbose=false){
        for(int i=0; i<state.size(); ++i){
            if(verbose)
                printf("{%d, %d}: %d, ", i, state[i], getCost({i, state[i]}));
            else
                printf("%d, ", state[i]);
        }
        printf(" Score: %d\n", h(state));
    }

    void testPrint(){
        // vector<int> sol = bestFirstSearch(18000); 
        // vector<int> sol = hillClimbing(start(), 3); 
        vector<int> sol = beamSearch(18000, 2); 
        // vector<int> sol = vnd(); 
        // pii sol = beamSearch(N, 13);
        printPath(sol);
        cout << "BFS Total cost = " << h(sol) << "\n";

        vector<int> test ;
        for(int i=0 ; i<6; ++i)
            test.push_back(i);
    }
};


int main(){
    JobAllocation solver;
    solver.input();
    solver.testPrint();
    return 0;
}