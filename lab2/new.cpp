#include <bits/stdc++.h>
using namespace std;
#define pii pair<int, int>

pii nil = {-1, -1};



struct Node{
    int path_cost; // accumulated cost
    int color; // visited = 1, else 0 
    int score; // score generated by heuristic
    bool visited; 
    pii parent;

    bool operator <(const Node &n) const{
        return path_cost < n.path_cost; 
    }

    Node(){
        path_cost = 0;
        color = 0;
        score = 0;
        visited = false;
        parent = nil;
    }
};


class JobAllocation{
    vector<vector<int>> cost;
    vector<vector<Node>> G;
    int N;

    set<string> open, closed; 

    
    // cost:   Jobs ->
    // Person
    // |
    // âŒ„

    Node& getNode(pii pos){
        return G[pos.first][pos.second];
    }


    int getCost(pii pos){
        if(pos == nil)
            return 0;
        return cost[pos.first][pos.second];
    }

    
    int getScore(pii pos){
        if(pos == nil)
            return -1;
        return getNode(pos).score;
    }


    int getPathCost(pii pos){
        if(pos == nil)
            return 0;
        return getNode(pos).path_cost;
    }


    vector<pii> getPath(pii pos){
        vector<pii> path;
        for(pii node=pos; node!=nil; node=getNode(node).parent){
            path.push_back(node);
        }
        return path;
    }


    bool goalTest(vector<int> state, int constraint=INT_MAX){
        /* 
         *  Checks if every job is assigned to a unique person
         *   
         * @params:
         *          state(vector<pii>): vector of assignments in form of (personIndex, jobIndex)
         *          constraint(int): maximum bound constraint for path cost
         * @return:
         *          Boolean of whether state is equal to goal or not.
         */
        if(state.empty())
            return false;
        
        set<int> uniqueJob;
        for(int job: state){
            uniqueJob.insert(job);
        }

        // cout << (uniqueJob.size() == N);
        // cout << (uniquePerson.size() == N);
        return (
            (uniqueJob.size() == N) && 
            (h(state) <= constraint)
        );
    }


    vector<vector<int>> movegen(vector<int> node){
        int cost = h(node);
        vector<vector<int>> neighbours;

        // For all pairs
        for(int i=0; i<N-1; ++i){
            for(int j=i+1; j<N; ++j){
                
                vector<int> neighbour = node;
                swap(neighbour[i], neighbour[j]);
                neighbours.push_back(neighbour);
                
                // cout << "Pushed: ";
                // for(int i: neighbour)
                //     printf("%d, ", i);
                // cout << "\n";
                
            }
        }            
        return neighbours;
    }
    


    int lookAhead(vector<pii> nextMoves, pii pos){
        int i = nextMoves.front().first + 1;
        int sum = 0;

        // printf("nextMoves: \n");
        vector<int> jobsFree;
        for(pii pair: nextMoves){
            // printf("{%d, %d} \n", pair.first, pair.second);
            if(pair != pos)
                jobsFree.push_back(pair.second);
        }
        
        for(; i<N; ++i){
            for(int j: jobsFree){
                sum += cost[i][j];
                // printf("Add %d, %d\n", i, j);
            }
        }
        // printf("Cost: %d, LookAhead: %d\n\n", getCost(pos), sum);
        return sum;
    }


    int h(vector<int> node){
        int sum = 0;
        for(int i=0; i<node.size(); ++i)
            sum += getCost({i, node[i]});        
        return sum;
    }
    

    vector<int> headSortMovegen(vector<int> node){
        int cost = h(node);
        pii exchangePos = nil;

        // For all pairs
        for(int i=0; i<N-1; ++i){
            for(int j=i+1; j<N; ++j){
                int newCost = cost - getCost({i, node[i]}) - getCost({j, node[j]}) + getCost({i, node[j]}) + getCost({j, node[i]});
                if(newCost < cost){
                    cost = newCost;
                    exchangePos = {i, j};
                }
            }
        }

        if(exchangePos != nil)
            swap(node[exchangePos.first], node[exchangePos.second]);
            
        return node;
    }


    string toString(vector<int> node){
        string state = "";
        for(int i: node)
            state += to_string(i) + ",";
        return state;
    }


    // printQ(priority_queue<vector<int>, vector<vector<int>>, function<bool(vector<int>, vector<int>)>> Q){

    // }


    vector<int> bestFirstSearch(int constraint=INT_MAX){
        
        // Init
        vector<int> source;
        for(int i=0; i<N; ++i)
            source.push_back(i);


        priority_queue<vector<int>, vector<vector<int>>, function<bool(vector<int>, vector<int>)>> Q( [this](vector<int> l, vector<int> r) -> bool {// Lambda Comparator Constructor for function<>
                // Min Priority Queue based on score
                return (h(l) > h(r));
        });
        

        // Push Source,
        Q.push(source);
        while(!Q.empty()){

            // Get top of queue
            vector<int> node = Q.top();
            Q.pop();
            cout << "Q: " << Q.size() << "\n";

            printf("Popped: ");
            for(int i:node)
                printf("%d, ", i);
            printf(" Score: %d\n", h(node));

            // // Mark visited
            // if(!node.empty()){
            //     closed.insert(toString(node));
            // }
            
            // Test Goal
            if(goalTest(node, constraint)){
                cout << "Goal Found\n";
                return node;
            }

            // Explore successor moves
            for(vector<int> move: movegen(source)){
                if(closed.find(toString(move)) == closed.end()){
                    closed.insert(toString(move));
                    Q.push(move);
                }else{
                    cout<<"dint push this\n";
                    for(int i:move)
                        printf("%d, ", i);
                    printf(" Score: %d\n", h(node));
                }
            }
        }
        return source;
        
    }


    vector<int> hillClimbing(){
        
        vector<int> node;
        
        // Init
        for(int i=0; i<N; ++i)
            node.push_back(i);
        
        vector<int> newNode = headSortMovegen(node);

        while(h(newNode) < h(node)){
            node = newNode;
            
            for(int i: node)
                cout << i << " ";
            cout << "\n";

            newNode = headSortMovegen(node);
        }
        return newNode;
    }


public:
    void input(){
        int cell_cost;
        
        // Input dimension N
        cin >> N;
        
        // Input N x N cost matrix
        for(int i=0; i<N; ++i){
            vector<int> rowC;
            vector<Node> rowG;
            
            for(int j=0; j<N; ++j){
                cin >> cell_cost;
                rowC.push_back(cell_cost);
                rowG.push_back(Node());
            }
            JobAllocation::cost.push_back(rowC);
            JobAllocation::G.push_back(rowG);
        }
    }  


    void testPrint(){
        vector<int> sol = bestFirstSearch(18000); 
        // pii sol = beamSearch(N, 13);
        // printf("Total Cost: %d\n", getNode(sol).path_cost);
        // vector<int> sol = hillClimbing(); 
        for(int i=0; i<sol.size(); ++i){
            ;
            printf("{%d, %d}: %d, ", i, sol[i], getCost({i, sol[i]}));
        }
        cout << "\n";
        cout << "BFS Total cost = " << h(sol) << "\n";
    }
};


int main(){
    JobAllocation solver;
    solver.input();
    solver.testPrint();
    return 0;
}